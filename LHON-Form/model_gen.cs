//
//  model_gen.cs
//  LHON-Form
//
//  Created by Pooya Merat in 2016.
//

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using AviFile;
using System.Drawing.Drawing2D;
using System.Xml.Serialization;
using System.IO;

using Cudafy;
using Cudafy.Host;
using Cudafy.Atomics;
using Cudafy.Translator;
using System.Runtime.InteropServices;
using MathNet.Numerics.Distributions;

namespace LHON_Form
{
    public partial class Main_Form : Form
    {

        // Constants

        // Used as measure of comparison
        const float mdl_real_nerve_r = 750; // um
        const int mdl_real_num_axons = 1200000;

        float mdl_clearance = 0.2F; // um
        const float mdl_vessel_ratio = 0.1F; // 0 - 1

        const float axon_min_r = 0.19F / 2,
                    axon_max_r = 6.87F / 2,
                    axon_min_r_mean = 0.92F / 2,
                    axon_max_r_mean = 1.28F / 2;

        string axon_radius_cdf_file = @"../../../../Matlab\pdf_from_graph\axon_radius_cdf.tbl";
        string axon_mean_radius_file = @"../../../../Matlab\pdf_from_graph\axon_mean_radius.tbl";

        bool show_axon_order_mdl_gen = false;

        // ===================================================================
        //          reading CDF and Mean tables generated by Matlab
        // ===================================================================
        uint axon_mean_r_table_grid_siz;
        float[,] axon_mean_r_table;

        float[,] axon_cdf_table;
        float[] axon_cdf_table_radius;
        uint axon_cdf_table_num_dia, axon_cdf_table_num_prob;

        // Random Generator
        Random random = new Random();

        float get_axon_radius(float x, float y, bool strict_mdl_flg)
        {
            uint x_idx = (uint)((x / mdl_nerve_r + 1) * ((float)axon_mean_r_table_grid_siz / 2F)),
                 y_idx = (uint)((y / mdl_nerve_r + 1) * ((float)axon_mean_r_table_grid_siz / 2F));
            if (x_idx >= axon_mean_r_table_grid_siz) x_idx = axon_mean_r_table_grid_siz - 1;
            if (y_idx >= axon_mean_r_table_grid_siz) y_idx = axon_mean_r_table_grid_siz - 1;

            float r_mean = axon_mean_r_table[x_idx, y_idx];

            if (strict_mdl_flg) return r_mean;

            for (x_idx = 0; x_idx < axon_cdf_table_num_dia; x_idx++)
                if (axon_cdf_table_radius[x_idx] > r_mean) break;
            if (x_idx >= axon_cdf_table_num_dia) x_idx = axon_cdf_table_num_dia - 1;
            y_idx = (uint)(random.NextDouble() * (double)axon_cdf_table_num_prob);

            float r = axon_cdf_table[x_idx, y_idx];

            return r;
        }

        void load_mdl_mean_r_table()
        {
            if (File.Exists(axon_mean_radius_file))
            {
                using (BinaryReader reader = new BinaryReader(File.Open(axon_mean_radius_file, FileMode.Open)))
                {
                    axon_mean_r_table_grid_siz = reader.ReadUInt32();
                    axon_mean_r_table = new float[axon_mean_r_table_grid_siz, axon_mean_r_table_grid_siz];

                    for (int r = 0; r < axon_mean_r_table_grid_siz; r++)
                        for (int c = 0; c < axon_mean_r_table_grid_siz; c++)
                            axon_mean_r_table[r, c] = reader.ReadSingle();
                }
            }
            else
                append_stat_ln("axon_mean_radius_file could not be found.");
        }

        void load_mdl_cdf_table()
        {
            if (File.Exists(axon_radius_cdf_file))
            {
                using (BinaryReader reader = new BinaryReader(File.Open(axon_radius_cdf_file, FileMode.Open)))
                {
                    axon_cdf_table_num_dia = reader.ReadUInt32();
                    axon_cdf_table_num_prob = reader.ReadUInt32() - 1;
                    axon_cdf_table = new float[axon_cdf_table_num_dia, axon_cdf_table_num_prob];
                    axon_cdf_table_radius = new float[axon_cdf_table_num_dia];

                    for (int r = 0; r < axon_cdf_table_num_dia; r++)
                        axon_cdf_table_radius[r] = reader.ReadSingle();
                    for (int c = 0; c < axon_cdf_table_num_prob; c++)
                        for (int r = 0; r < axon_cdf_table_num_dia; r++)
                            axon_cdf_table[r, c] = reader.ReadSingle();
                }
            }
            else
                append_stat_ln("axon_radius_cdf_file could not be found.");
        }

        // ===================================================================
        //                  Model Generation using Circle Packing
        // ===================================================================

        float mdl_nerve_r = 0;

        [Serializable]
        public class Model
        {
            public float nerve_scale_ratio, vessel_ratio, clearance;

            public int n_axons;
            public List<float[]> axon_coor;
        }
        public void save_mdl(string filePath)
        {
            var fs = new FileStream(filePath, FileMode.Append, FileAccess.Write);
            var b = new BinaryWriter(fs);

            b.Write(mdl.nerve_scale_ratio);
            b.Write(mdl.n_axons);
            for (int k = 0; k < mdl.n_axons; k++)
                for (int i = 0; i < 3; i++)
                    b.Write(mdl.axon_coor[k][i]);
            fs.Close();
        }
        public void load_mdl(string filePath)
        {
            var fs = new FileStream(filePath, FileMode.Open);
            BinaryReader b = new BinaryReader(fs);

            model_id = B36toDec(Path.GetFileName(filePath).Split(' ')[0]);
            Debug.WriteLine(model_id);
            
            mdl.nerve_scale_ratio = b.ReadSingle();
            mdl.n_axons = b.ReadInt32();
            mdl.axon_coor = new List<float[]>();
            for (int k = 0; k < mdl.n_axons; k++)
            {
                float[] coor = new float[3];
                for (int i = 0; i < 3; i++)
                    coor[i] = b.ReadSingle();
                mdl.axon_coor.Add(coor);
            }
            fs.Close();
        }

        float x0 = 0, y0 = 0, r, r1 = 0; // in length unit
        float x2 = 0, x1 = 0, y2 = 0, y1 = 0; // in length unit
        float angle = 0;
        int xc = 0, yc = 0, rc = 0; // in pixels
        int rc_clear, rc_clear2, rc2, box_x0, box_y0, box_x1, box_y1;

        float mdl_resolution;

        bool[,] mdl_occupied_pix;

        List<float[]> mdl_axons_coor;
        int mdl_n_axons;

        axon_lbl_class[] mdl_axon_lbl;


        // takes Xc, Yc and Rc and updates all pixel-based params
        void update_box()
        {
            xc = cor_to_pix(x0);
            yc = cor_to_pix(y0);
            rc = (int)(r * mdl_resolution);
            rc2 = rc * rc;

            rc_clear = rc + (int)(mdl_clearance * mdl_resolution);
            rc_clear2 = (rc_clear - 1) * (rc_clear - 1);
            box_x0 = Max(xc - rc_clear, 0);
            box_y0 = Max(yc - rc_clear, 0);
            box_x1 = Min(xc + rc_clear + 1, im_size);
            box_y1 = Min(yc + rc_clear + 1, im_size);
        }

        bool check_overlap()
        {
            for (int y = box_y0; y < box_y1; y++)
                for (int x = box_x0; x < box_x1; x++)
                {
                    float dx = x - xc;
                    float dy = y - yc;
                    if (rc_clear2 - (dx * dx + dy * dy) >= 0)
                        if (mdl_occupied_pix[x, y])
                            return true;
                }
            return false;
        }

        int cor_to_pix(float X)
        {
            return (int)((X + mdl_nerve_r) * mdl_resolution);
        }

        private void new_model()
        {
            // new_model is resolution independent. Numbers are in length unit.

            load_mdl_mean_r_table();
            load_mdl_cdf_table();
            mdl_nerve_r = mdl.nerve_scale_ratio * mdl_real_nerve_r;

            sim_stat = sim_stat_enum.Running;

            mdl_axons_coor = new List<float[]>();
            mdl_n_axons = 0;

            bool strict_mdl_flg = chk_strict_rad.Checked;

            update_bottom_stat("Generating Model...");

            mdl_resolution = 25; // Resolution of image during model generation

            im_size = (ushort)(mdl_nerve_r * 2 * mdl_resolution);

            mdl_occupied_pix = new bool[im_size, im_size];

            x0 = 0; y0 = 0; x2 = 0; x1 = 0; y2 = 0; y1 = 0; r1 = 0;
            angle = 0;

            float angle_step = 0.08F;
            float distance_step = mdl_clearance / 2;

            tic();

            int num_tries = (int)(3 * mdl_nerve_r * mdl_nerve_r);

            for (int i = 0; i < num_tries; i++)
            {
                // =================================

                if (i % 20 == 0) update_mdl_prog((float)i / num_tries);

                r = get_axon_radius(x1, y1, strict_mdl_flg);

                if (i > 0)
                {
                    float dist = r + r1 + mdl_clearance;
                    x0 = x1 + (float)Math.Cos(angle) * dist;
                    y0 = y1 + (float)Math.Sin(angle) * dist;

                    if (i > 1)
                    {
                        bool intitial_overlap = true;
                        float Xcg = 0, Ycg = 0; // last successful coords
                        float angle_init = angle;
                        while (true)
                        {
                            x0 = x1 + (float)Math.Cos(angle) * dist;
                            y0 = y1 + (float)Math.Sin(angle) * dist;

                            update_box();
                            if (check_overlap())
                            {
                                if (intitial_overlap)
                                {
                                    angle -= angle_step;
                                    if (Math.Abs(angle - angle_init) >= Math.PI)
                                    {
                                        dist += distance_step;
                                        angle = angle_init;
                                    }
                                }
                                else
                                {
                                    // revert to the last non-overlapping case
                                    x0 = Xcg;
                                    y0 = Ycg;
                                    angle -= angle_step;
                                    break;
                                }
                            }
                            else
                            {
                                intitial_overlap = false;
                                Xcg = x0;
                                Ycg = y0;
                                angle += angle_step;
                            }
                        }
                    }
                }

                update_box();

                // Add neuron
                for (int y = box_y0; y < box_y1; y++)
                    for (int x = box_x0; x < box_x1; x++)
                        if (within_circle2(x, y, xc, yc, rc) > 0)
                            mdl_occupied_pix[x, y] = true;

                mdl_axons_coor.Add(new float[3] { x0, y0, r });
                mdl_n_axons++;

                if (i % 10 == 0) update_num_axons_lbl();

                x2 = x1; x1 = x0;
                y2 = y1; y1 = y0;
                r1 = r;

            }
            mdl.axon_coor = new List<float[]>();
            mdl.n_axons = 0;

            if (show_axon_order_mdl_gen)
                mdl_axon_lbl = new axon_lbl_class[mdl_n_axons];

            int idx = 0;
            for (int i = 0; i < mdl_n_axons; i++)
            {
                float cent_dis = (float)Math.Sqrt(mdl_axons_coor[i][0] * mdl_axons_coor[i][0] +
                    mdl_axons_coor[i][1] * mdl_axons_coor[i][1]);
                if (cent_dis + mdl_axons_coor[i][2] > mdl_nerve_r) continue;
                if (cent_dis - mdl_axons_coor[i][2] < mdl_vessel_ratio * mdl_nerve_r) continue;

                mdl.axon_coor.Add(mdl_axons_coor[i]);
                mdl.n_axons++;

                int mdl_gen_im_siz = im_size = calc_im_siz();

                if (show_axon_order_mdl_gen)
                {
                    float tempx = mdl_axons_coor[i][0] * setts.resolution + mdl_gen_im_siz / 2;
                    float tempy = mdl_axons_coor[i][1] * setts.resolution + mdl_gen_im_siz / 2;
                    mdl_axon_lbl[idx] = new axon_lbl_class { lbl = (i + 1).ToString("0"), x = tempx, y = tempy };
                    idx++;
                }
            }

            model_id = DateTime.Now.Ticks / 1000;
            model_is_saved = false;
            sim_stat = sim_stat_enum.None;

            append_stat("Model Generated in " + (toc() / 1000).ToString("0.0") + " secs\n");
            Debug.WriteLine("model done");
            update_num_axons_lbl();
            

            preprocess_model();
        }
    }
}

/*
float sample_radius_obsolete(float x, float y, bool strict_mdl_flg)
{
    float r_mean = axon_min_r_mean + (x + mdl.nerve_r) / (mdl.nerve_r * 2) * (axon_max_r_mean - axon_min_r_mean);

    if (strict_mdl_flg) return r_mean;

    double alpha = 3;
    double beta = (r_mean - axon_min_r) / (axon_max_r - axon_min_r) * (alpha - 1);
    //double nrm_rnd = (1 / Gamma.Sample(alpha, 1 / beta));
    float r;
    do
    {
        //MathNet.Numerics.Distributions.Normal
        double samp = InverseGamma.Sample(alpha, beta);
        //double samp = 1 / Gamma.Sample(alpha, 1 / beta);
        r = (float)(axon_min_r + samp * (axon_max_r - axon_min_r));
    }
    while (r >= axon_max_r);

    return r;
}
*/
